// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_Type
#include <hxinc/Type.h>
#endif
#ifndef INCLUDED_bonsai_entity_Entity
#include <hxinc/bonsai/entity/Entity.h>
#endif
#ifndef INCLUDED_game_BodyPart
#include <hxinc/game/BodyPart.h>
#endif
#ifndef INCLUDED_game_Inventory
#include <hxinc/game/Inventory.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <hxinc/haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_BalancedTree
#include <hxinc/haxe/ds/BalancedTree.h>
#endif
#ifndef INCLUDED_haxe_ds_EnumValueMap
#include <hxinc/haxe/ds/EnumValueMap.h>
#endif
#ifndef INCLUDED_haxe_iterators_MapKeyValueIterator
#include <hxinc/haxe/iterators/MapKeyValueIterator.h>
#endif
#ifndef INCLUDED_kha_Assets
#include <hxinc/kha/Assets.h>
#endif
#ifndef INCLUDED_kha_Kravur
#include <hxinc/kha/Kravur.h>
#endif
#ifndef INCLUDED_kha_Resource
#include <hxinc/kha/Resource.h>
#endif
#ifndef INCLUDED_kha__Assets_FontList
#include <hxinc/kha/_Assets/FontList.h>
#endif
#ifndef INCLUDED_kha__Color_Color_Impl_
#include <hxinc/kha/_Color/Color_Impl_.h>
#endif
#ifndef INCLUDED_kha_graphics2_Graphics
#include <hxinc/kha/graphics2/Graphics.h>
#endif
#ifndef INCLUDED_kha_math_Vector2
#include <hxinc/kha/math/Vector2.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_90b2490a7e87b451_3_new,"game.Inventory","new",0xf3dc17f2,"game.Inventory.new","game/Inventory.hx",3,0xf0bf293f)
HX_LOCAL_STACK_FRAME(_hx_pos_90b2490a7e87b451_11_getItemClicked,"game.Inventory","getItemClicked",0x9fd8e28c,"game.Inventory.getItemClicked","game/Inventory.hx",11,0xf0bf293f)
HX_LOCAL_STACK_FRAME(_hx_pos_90b2490a7e87b451_25_render,"game.Inventory","render",0x4548ab04,"game.Inventory.render","game/Inventory.hx",25,0xf0bf293f)
namespace game{

void Inventory_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_90b2490a7e87b451_3_new)
HXLINE(   4)		this->_hx_set_items(HX_CTX,  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX ));
HXLINE(   7)		 ::haxe::ds::EnumValueMap _g =  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX );
HXDLIN(   7)		{
HXLINE(   7)			int _g1 = 0;
HXDLIN(   7)			::Array< ::Dynamic> _g2 = ::Type_obj::allEnums(hx::ClassOf< ::game::BodyPart >());
HXDLIN(   7)			while((_g1 < _g2->length)){
HXLINE(   7)				 ::game::BodyPart part = _g2->__get(_g1).StaticCast<  ::game::BodyPart >();
HXDLIN(   7)				_g1 = (_g1 + 1);
HXDLIN(   7)				_g->set(part,0);
            			}
            		}
HXDLIN(   7)		this->_hx_set_items(HX_CTX, _g);
HXLINE(   8)		super::__construct();
            	}

Dynamic Inventory_obj::__CreateEmpty() { return new Inventory_obj; }

void *Inventory_obj::_hx_vtable = 0;

Dynamic Inventory_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Inventory_obj > _hx_result = new Inventory_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Inventory_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0632590a) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0632590a;
	} else {
		return inClassId==(int)0x61169fa0;
	}
}

 ::game::BodyPart Inventory_obj::getItemClicked( ::kha::math::Vector2 position){
            	HX_GC_STACKFRAME(&_hx_pos_90b2490a7e87b451_11_getItemClicked)
HXLINE(  12)		if ((position->x < 250)) {
HXLINE(  13)			int yOffset = 1;
HXLINE(  14)			{
HXLINE(  14)				 ::Dynamic _g =  ::haxe::iterators::MapKeyValueIterator_obj::__alloc( HX_CTX ,this->items);
HXDLIN(  14)				while(( (bool)(_g->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  14)					 ::Dynamic _g1 = _g->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)();
HXDLIN(  14)					 ::game::BodyPart item = _g1->__Field(HX_("key",9f,89,51,00),hx::paccDynamic);
HXDLIN(  14)					int quantity = ( (int)(_g1->__Field(HX_("value",71,7f,b8,31),hx::paccDynamic)) );
HXLINE(  15)					if ((quantity > 0)) {
HXLINE(  16)						bool _hx_tmp;
HXDLIN(  16)						if ((position->y > ((yOffset * 40) - 2))) {
HXLINE(  16)							_hx_tmp = (position->y < (((yOffset * 40) - 2) + 34));
            						}
            						else {
HXLINE(  16)							_hx_tmp = false;
            						}
HXDLIN(  16)						if (_hx_tmp) {
HXLINE(  17)							return item;
            						}
HXLINE(  18)						yOffset = (yOffset + 1);
            					}
            				}
            			}
            		}
HXLINE(  22)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,getItemClicked,return )

void Inventory_obj::render( ::kha::graphics2::Graphics graphics){
            	HX_GC_STACKFRAME(&_hx_pos_90b2490a7e87b451_25_render)
HXLINE(  26)		int yOffset = 1;
HXLINE(  27)		graphics->set_fontSize(30);
HXLINE(  29)		int total = 1;
HXLINE(  30)		{
HXLINE(  30)			 ::Dynamic _g =  ::haxe::iterators::MapKeyValueIterator_obj::__alloc( HX_CTX ,this->items);
HXDLIN(  30)			while(( (bool)(_g->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  30)				 ::Dynamic _g1 = _g->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)();
HXDLIN(  30)				 ::game::BodyPart item = _g1->__Field(HX_("key",9f,89,51,00),hx::paccDynamic);
HXDLIN(  30)				int quantity = ( (int)(_g1->__Field(HX_("value",71,7f,b8,31),hx::paccDynamic)) );
HXLINE(  31)				if ((quantity > 0)) {
HXLINE(  32)					total = (total + 1);
            				}
            			}
            		}
HXLINE(  34)		graphics->set_color(::kha::_Color::Color_Impl__obj::fromBytes(26,24,23,null()));
HXLINE(  35)		graphics->fillRect(( (Float)(0) ),( (Float)(0) ),( (Float)(253) ),( (Float)((total * 40)) ));
HXLINE(  37)		graphics->set_color(::kha::_Color::Color_Impl__obj::fromBytes(36,34,33,null()));
HXLINE(  38)		graphics->set_font(::kha::Assets_obj::fonts->KenneyMiniSquare);
HXLINE(  39)		graphics->set_color(-1);
HXLINE(  40)		graphics->drawString(HX_("Inventory:",3e,56,a2,4d),( (Float)(5) ),( (Float)(0) ));
HXLINE(  42)		graphics->set_font(::kha::Assets_obj::fonts->KenneyMini);
HXLINE(  44)		{
HXLINE(  44)			 ::Dynamic _g2 =  ::haxe::iterators::MapKeyValueIterator_obj::__alloc( HX_CTX ,this->items);
HXDLIN(  44)			while(( (bool)(_g2->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  44)				 ::Dynamic _g11 = _g2->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)();
HXDLIN(  44)				 ::game::BodyPart item1 = _g11->__Field(HX_("key",9f,89,51,00),hx::paccDynamic);
HXDLIN(  44)				int quantity1 = ( (int)(_g11->__Field(HX_("value",71,7f,b8,31),hx::paccDynamic)) );
HXLINE(  45)				if ((quantity1 > 0)) {
HXLINE(  46)					graphics->set_color(::kha::_Color::Color_Impl__obj::fromBytes(36,34,33,null()));
HXLINE(  47)					graphics->fillRect(( (Float)(3) ),( (Float)(((yOffset * 40) - 2)) ),( (Float)(250) ),( (Float)(34) ));
HXLINE(  48)					graphics->set_color(-1);
HXLINE(  49)					graphics->drawString((HX_("",00,00,00,00) + quantity1),( (Float)(5) ),( (Float)((yOffset * 40)) ));
HXLINE(  50)					graphics->drawString((HX_("",00,00,00,00) + ::Std_obj::string(item1)),( (Float)(70) ),( (Float)((yOffset * 40)) ));
HXLINE(  52)					yOffset = (yOffset + 1);
            				}
            			}
            		}
            	}



hx::ObjectPtr< Inventory_obj > Inventory_obj::__new() {
	hx::ObjectPtr< Inventory_obj > __this = new Inventory_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Inventory_obj > Inventory_obj::__alloc(hx::Ctx *_hx_ctx) {
	Inventory_obj *__this = (Inventory_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Inventory_obj), true, "game.Inventory"));
	*(void **)__this = Inventory_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Inventory_obj::Inventory_obj()
{
}

void Inventory_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Inventory);
	HX_MARK_MEMBER_NAME(items,"items");
	 ::bonsai::entity::Entity_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Inventory_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(items,"items");
	 ::bonsai::entity::Entity_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Inventory_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"items") ) { return hx::Val( items ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return hx::Val( render_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getItemClicked") ) { return hx::Val( getItemClicked_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Inventory_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"items") ) { _hx_set_items(HX_CTX_GET,inValue.Cast<  ::haxe::ds::EnumValueMap >()); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Inventory_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("items",00,ac,0c,c2));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Inventory_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::haxe::ds::EnumValueMap */ ,(int)offsetof(Inventory_obj,items),HX_("items",00,ac,0c,c2)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Inventory_obj_sStaticStorageInfo = 0;
#endif

static ::String Inventory_obj_sMemberFields[] = {
	HX_("items",00,ac,0c,c2),
	HX_("getItemClicked",de,44,cd,df),
	HX_("render",56,6b,29,05),
	::String(null()) };

hx::Class Inventory_obj::__mClass;

void Inventory_obj::__register()
{
	Inventory_obj _hx_dummy;
	Inventory_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("game.Inventory",00,f7,d8,0f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Inventory_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Inventory_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Inventory_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Inventory_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace game
