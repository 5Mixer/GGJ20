// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_differ_data_RayCollision
#include <hxinc/differ/data/RayCollision.h>
#endif
#ifndef INCLUDED_differ_data_ShapeCollision
#include <hxinc/differ/data/ShapeCollision.h>
#endif
#ifndef INCLUDED_differ_sat_SAT2D
#include <hxinc/differ/sat/SAT2D.h>
#endif
#ifndef INCLUDED_differ_shapes_Circle
#include <hxinc/differ/shapes/Circle.h>
#endif
#ifndef INCLUDED_differ_shapes_Polygon
#include <hxinc/differ/shapes/Polygon.h>
#endif
#ifndef INCLUDED_differ_shapes_Ray
#include <hxinc/differ/shapes/Ray.h>
#endif
#ifndef INCLUDED_differ_shapes_Shape
#include <hxinc/differ/shapes/Shape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_18_new,"differ.shapes.Circle","new",0x4044b422,"differ.shapes.Circle.new","differ/shapes/Circle.hx",18,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_29_test,"differ.shapes.Circle","test",0xffd02e50,"differ.shapes.Circle.test","differ/shapes/Circle.hx",29,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_36_testCircle,"differ.shapes.Circle","testCircle",0x207db080,"differ.shapes.Circle.testCircle","differ/shapes/Circle.hx",36,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_43_testPolygon,"differ.shapes.Circle","testPolygon",0x6a57660a,"differ.shapes.Circle.testPolygon","differ/shapes/Circle.hx",43,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_50_testRay,"differ.shapes.Circle","testRay",0x5f20317a,"differ.shapes.Circle.testRay","differ/shapes/Circle.hx",50,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_58_get_radius,"differ.shapes.Circle","get_radius",0x52fa3899,"differ.shapes.Circle.get_radius","differ/shapes/Circle.hx",58,0x898eef6e)
HX_LOCAL_STACK_FRAME(_hx_pos_38e21513ffd4ef1b_64_get_transformedRadius,"differ.shapes.Circle","get_transformedRadius",0x9a322696,"differ.shapes.Circle.get_transformedRadius","differ/shapes/Circle.hx",64,0x898eef6e)
namespace differ{
namespace shapes{

void Circle_obj::__construct(Float x,Float y,Float radius){
            	HX_GC_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_18_new)
HXLINE(  20)		super::__construct(x,y);
HXLINE(  21)		this->_radius = radius;
HXLINE(  22)		this->_hx_set_name(HX_CTX, (HX_("circle ",10,5c,b6,f5) + this->_radius));
            	}

Dynamic Circle_obj::__CreateEmpty() { return new Circle_obj; }

void *Circle_obj::_hx_vtable = 0;

Dynamic Circle_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Circle_obj > _hx_result = new Circle_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Circle_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x059b76f8) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x059b76f8;
	} else {
		return inClassId==(int)0x3c9cf339;
	}
}

 ::differ::data::ShapeCollision Circle_obj::test( ::differ::shapes::Shape shape, ::differ::data::ShapeCollision into){
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_29_test)
HXDLIN(  29)		return shape->testCircle(hx::ObjectPtr<OBJ_>(this),into,true);
            	}


 ::differ::data::ShapeCollision Circle_obj::testCircle( ::differ::shapes::Circle circle, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_36_testCircle)
HXDLIN(  36)		return ::differ::sat::SAT2D_obj::testCircleVsCircle(hx::ObjectPtr<OBJ_>(this),circle,into,flip);
            	}


 ::differ::data::ShapeCollision Circle_obj::testPolygon( ::differ::shapes::Polygon polygon, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_43_testPolygon)
HXDLIN(  43)		return ::differ::sat::SAT2D_obj::testCircleVsPolygon(hx::ObjectPtr<OBJ_>(this),polygon,into,flip);
            	}


 ::differ::data::RayCollision Circle_obj::testRay( ::differ::shapes::Ray ray, ::differ::data::RayCollision into){
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_50_testRay)
HXDLIN(  50)		return ::differ::sat::SAT2D_obj::testRayVsCircle(ray,hx::ObjectPtr<OBJ_>(this),into);
            	}


Float Circle_obj::get_radius(){
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_58_get_radius)
HXDLIN(  58)		return this->_radius;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Circle_obj,get_radius,return )

Float Circle_obj::get_transformedRadius(){
            	HX_STACKFRAME(&_hx_pos_38e21513ffd4ef1b_64_get_transformedRadius)
HXDLIN(  64)		Float _hx_tmp = this->_radius;
HXDLIN(  64)		return (_hx_tmp * this->get_scaleX());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Circle_obj,get_transformedRadius,return )


hx::ObjectPtr< Circle_obj > Circle_obj::__new(Float x,Float y,Float radius) {
	hx::ObjectPtr< Circle_obj > __this = new Circle_obj();
	__this->__construct(x,y,radius);
	return __this;
}

hx::ObjectPtr< Circle_obj > Circle_obj::__alloc(hx::Ctx *_hx_ctx,Float x,Float y,Float radius) {
	Circle_obj *__this = (Circle_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Circle_obj), true, "differ.shapes.Circle"));
	*(void **)__this = Circle_obj::_hx_vtable;
	__this->__construct(x,y,radius);
	return __this;
}

Circle_obj::Circle_obj()
{
}

hx::Val Circle_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"test") ) { return hx::Val( test_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"radius") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_radius() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_radius") ) { return hx::Val( _radius ); }
		if (HX_FIELD_EQ(inName,"testRay") ) { return hx::Val( testRay_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"testCircle") ) { return hx::Val( testCircle_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_radius") ) { return hx::Val( get_radius_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"testPolygon") ) { return hx::Val( testPolygon_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"transformedRadius") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_transformedRadius() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"get_transformedRadius") ) { return hx::Val( get_transformedRadius_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Circle_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"_radius") ) { _radius=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Circle_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("radius",52,d0,f6,b0));
	outFields->push(HX_("transformedRadius",7d,27,b5,b2));
	outFields->push(HX_("_radius",f1,e1,6d,1f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Circle_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Circle_obj,_radius),HX_("_radius",f1,e1,6d,1f)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Circle_obj_sStaticStorageInfo = 0;
#endif

static ::String Circle_obj_sMemberFields[] = {
	HX_("_radius",f1,e1,6d,1f),
	HX_("test",52,c8,f9,4c),
	HX_("testCircle",02,b8,01,6f),
	HX_("testPolygon",48,f0,59,cf),
	HX_("testRay",b8,44,c5,bd),
	HX_("get_radius",1b,40,7e,a1),
	HX_("get_transformedRadius",54,2a,63,31),
	::String(null()) };

hx::Class Circle_obj::__mClass;

void Circle_obj::__register()
{
	Circle_obj _hx_dummy;
	Circle_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("differ.shapes.Circle",30,bb,53,6a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Circle_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Circle_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Circle_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Circle_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace differ
} // end namespace shapes
