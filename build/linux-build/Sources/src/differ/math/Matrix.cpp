// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_differ_math_Matrix
#include <hxinc/differ/math/Matrix.h>
#endif
#ifndef INCLUDED_differ_math_Vector
#include <hxinc/differ/math/Vector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_bd56dd91510c4f84_10_new,"differ.math.Matrix","new",0x4b31bffd,"differ.math.Matrix.new","differ/math/Matrix.hx",10,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_34_identity,"differ.math.Matrix","identity",0xfe769c81,"differ.math.Matrix.identity","differ/math/Matrix.hx",34,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_45_translate,"differ.math.Matrix","translate",0xa2a4daab,"differ.math.Matrix.translate","differ/math/Matrix.hx",45,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_52_compose,"differ.math.Matrix","compose",0x2b5e3b2f,"differ.math.Matrix.compose","differ/math/Matrix.hx",52,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_62_makeTranslation,"differ.math.Matrix","makeTranslation",0xd83480c0,"differ.math.Matrix.makeTranslation","differ/math/Matrix.hx",62,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_71_rotate,"differ.math.Matrix","rotate",0x4a2836de,"differ.math.Matrix.rotate","differ/math/Matrix.hx",71,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_90_scale,"differ.math.Matrix","scale",0xaabd9f67,"differ.math.Matrix.scale","differ/math/Matrix.hx",90,0x894525b3)
HX_LOCAL_STACK_FRAME(_hx_pos_bd56dd91510c4f84_105_toString,"differ.math.Matrix","toString",0x7db627ef,"differ.math.Matrix.toString","differ/math/Matrix.hx",105,0x894525b3)
namespace differ{
namespace math{

void Matrix_obj::__construct(hx::Null< Float >  __o_a,hx::Null< Float >  __o_b,hx::Null< Float >  __o_c,hx::Null< Float >  __o_d,hx::Null< Float >  __o_tx,hx::Null< Float >  __o_ty){
            		Float a = __o_a.Default(1);
            		Float b = __o_b.Default(0);
            		Float c = __o_c.Default(0);
            		Float d = __o_d.Default(1);
            		Float tx = __o_tx.Default(0);
            		Float ty = __o_ty.Default(0);
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_10_new)
HXLINE(  21)		this->_last_rotation = ((Float)0);
HXLINE(  25)		this->a = a;
HXLINE(  26)		this->b = b;
HXLINE(  27)		this->c = c;
HXLINE(  28)		this->d = d;
HXLINE(  29)		this->tx = tx;
HXLINE(  30)		this->ty = ty;
            	}

Dynamic Matrix_obj::__CreateEmpty() { return new Matrix_obj; }

void *Matrix_obj::_hx_vtable = 0;

Dynamic Matrix_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Matrix_obj > _hx_result = new Matrix_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

bool Matrix_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x61d3dcdb;
}

void Matrix_obj::identity(){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_34_identity)
HXLINE(  36)		this->a = ( (Float)(1) );
HXLINE(  37)		this->b = ( (Float)(0) );
HXLINE(  38)		this->c = ( (Float)(0) );
HXLINE(  39)		this->d = ( (Float)(1) );
HXLINE(  40)		this->tx = ( (Float)(0) );
HXLINE(  41)		this->ty = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix_obj,identity,(void))

void Matrix_obj::translate(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_45_translate)
HXLINE(  47)		 ::differ::math::Matrix _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  47)		_hx_tmp->tx = (_hx_tmp->tx + x);
HXLINE(  48)		 ::differ::math::Matrix _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  48)		_hx_tmp1->ty = (_hx_tmp1->ty + y);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix_obj,translate,(void))

void Matrix_obj::compose( ::differ::math::Vector _position,Float _rotation, ::differ::math::Vector _scale){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_52_compose)
HXLINE(  54)		this->identity();
HXLINE(  56)		this->scale(_scale->x,_scale->y);
HXLINE(  57)		this->rotate(_rotation);
HXLINE(  58)		this->makeTranslation(_position->x,_position->y);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix_obj,compose,(void))

 ::differ::math::Matrix Matrix_obj::makeTranslation(Float _x,Float _y){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_62_makeTranslation)
HXLINE(  64)		this->tx = _x;
HXLINE(  65)		this->ty = _y;
HXLINE(  67)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix_obj,makeTranslation,return )

void Matrix_obj::rotate(Float angle){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_71_rotate)
HXLINE(  73)		Float cos = ::Math_obj::cos(angle);
HXLINE(  74)		Float sin = ::Math_obj::sin(angle);
HXLINE(  76)		Float a1 = ((this->a * cos) - (this->b * sin));
HXLINE(  77)		this->b = ((this->a * sin) + (this->b * cos));
HXLINE(  78)		this->a = a1;
HXLINE(  80)		Float c1 = ((this->c * cos) - (this->d * sin));
HXLINE(  81)		this->d = ((this->c * sin) + (this->d * cos));
HXLINE(  82)		this->c = c1;
HXLINE(  84)		Float tx1 = ((this->tx * cos) - (this->ty * sin));
HXLINE(  85)		this->ty = ((this->tx * sin) + (this->ty * cos));
HXLINE(  86)		this->tx = tx1;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix_obj,rotate,(void))

void Matrix_obj::scale(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_90_scale)
HXLINE(  92)		 ::differ::math::Matrix _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  92)		_hx_tmp->a = (_hx_tmp->a * x);
HXLINE(  93)		 ::differ::math::Matrix _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  93)		_hx_tmp1->b = (_hx_tmp1->b * y);
HXLINE(  95)		 ::differ::math::Matrix _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  95)		_hx_tmp2->c = (_hx_tmp2->c * x);
HXLINE(  96)		 ::differ::math::Matrix _hx_tmp3 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  96)		_hx_tmp3->d = (_hx_tmp3->d * y);
HXLINE(  98)		 ::differ::math::Matrix _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  98)		_hx_tmp4->tx = (_hx_tmp4->tx * x);
HXLINE(  99)		 ::differ::math::Matrix _hx_tmp5 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  99)		_hx_tmp5->ty = (_hx_tmp5->ty * y);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix_obj,scale,(void))

::String Matrix_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_bd56dd91510c4f84_105_toString)
HXDLIN( 105)		return ((((((((((((HX_("(a=",e4,ae,1e,00) + this->a) + HX_(", b=",0f,01,2e,1d)) + this->b) + HX_(", c=",ee,01,2e,1d)) + this->c) + HX_(", d=",cd,02,2e,1d)) + this->d) + HX_(", tx=",45,c8,20,6b)) + this->tx) + HX_(", ty=",24,c9,20,6b)) + this->ty) + HX_(")",29,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix_obj,toString,return )


hx::ObjectPtr< Matrix_obj > Matrix_obj::__new(hx::Null< Float >  __o_a,hx::Null< Float >  __o_b,hx::Null< Float >  __o_c,hx::Null< Float >  __o_d,hx::Null< Float >  __o_tx,hx::Null< Float >  __o_ty) {
	hx::ObjectPtr< Matrix_obj > __this = new Matrix_obj();
	__this->__construct(__o_a,__o_b,__o_c,__o_d,__o_tx,__o_ty);
	return __this;
}

hx::ObjectPtr< Matrix_obj > Matrix_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< Float >  __o_a,hx::Null< Float >  __o_b,hx::Null< Float >  __o_c,hx::Null< Float >  __o_d,hx::Null< Float >  __o_tx,hx::Null< Float >  __o_ty) {
	Matrix_obj *__this = (Matrix_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Matrix_obj), false, "differ.math.Matrix"));
	*(void **)__this = Matrix_obj::_hx_vtable;
	__this->__construct(__o_a,__o_b,__o_c,__o_d,__o_tx,__o_ty);
	return __this;
}

Matrix_obj::Matrix_obj()
{
}

hx::Val Matrix_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"a") ) { return hx::Val( a ); }
		if (HX_FIELD_EQ(inName,"b") ) { return hx::Val( b ); }
		if (HX_FIELD_EQ(inName,"c") ) { return hx::Val( c ); }
		if (HX_FIELD_EQ(inName,"d") ) { return hx::Val( d ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"tx") ) { return hx::Val( tx ); }
		if (HX_FIELD_EQ(inName,"ty") ) { return hx::Val( ty ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return hx::Val( scale_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"rotate") ) { return hx::Val( rotate_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compose") ) { return hx::Val( compose_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"identity") ) { return hx::Val( identity_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"translate") ) { return hx::Val( translate_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_last_rotation") ) { return hx::Val( _last_rotation ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"makeTranslation") ) { return hx::Val( makeTranslation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Matrix_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"a") ) { a=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"b") ) { b=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"c") ) { c=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"d") ) { d=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"tx") ) { tx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ty") ) { ty=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_last_rotation") ) { _last_rotation=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Matrix_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("a",61,00,00,00));
	outFields->push(HX_("b",62,00,00,00));
	outFields->push(HX_("c",63,00,00,00));
	outFields->push(HX_("d",64,00,00,00));
	outFields->push(HX_("tx",84,65,00,00));
	outFields->push(HX_("ty",85,65,00,00));
	outFields->push(HX_("_last_rotation",c8,1f,d4,ea));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Matrix_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Matrix_obj,a),HX_("a",61,00,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,b),HX_("b",62,00,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,c),HX_("c",63,00,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,d),HX_("d",64,00,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,tx),HX_("tx",84,65,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,ty),HX_("ty",85,65,00,00)},
	{hx::fsFloat,(int)offsetof(Matrix_obj,_last_rotation),HX_("_last_rotation",c8,1f,d4,ea)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Matrix_obj_sStaticStorageInfo = 0;
#endif

static ::String Matrix_obj_sMemberFields[] = {
	HX_("a",61,00,00,00),
	HX_("b",62,00,00,00),
	HX_("c",63,00,00,00),
	HX_("d",64,00,00,00),
	HX_("tx",84,65,00,00),
	HX_("ty",85,65,00,00),
	HX_("_last_rotation",c8,1f,d4,ea),
	HX_("identity",3e,45,2f,b9),
	HX_("translate",4e,d7,7f,49),
	HX_("compose",12,b9,73,83),
	HX_("makeTranslation",a3,19,9f,b9),
	HX_("rotate",5b,46,20,cb),
	HX_("scale",8a,ce,ce,78),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

hx::Class Matrix_obj::__mClass;

void Matrix_obj::__register()
{
	Matrix_obj _hx_dummy;
	Matrix_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("differ.math.Matrix",8b,fd,00,43);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Matrix_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Matrix_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Matrix_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Matrix_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace differ
} // end namespace math
