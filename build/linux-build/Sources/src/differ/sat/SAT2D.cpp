// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_differ_data_RayCollision
#include <hxinc/differ/data/RayCollision.h>
#endif
#ifndef INCLUDED_differ_data_RayIntersection
#include <hxinc/differ/data/RayIntersection.h>
#endif
#ifndef INCLUDED_differ_data_ShapeCollision
#include <hxinc/differ/data/ShapeCollision.h>
#endif
#ifndef INCLUDED_differ_math_Vector
#include <hxinc/differ/math/Vector.h>
#endif
#ifndef INCLUDED_differ_sat_SAT2D
#include <hxinc/differ/sat/SAT2D.h>
#endif
#ifndef INCLUDED_differ_shapes_Circle
#include <hxinc/differ/shapes/Circle.h>
#endif
#ifndef INCLUDED_differ_shapes_InfiniteState
#include <hxinc/differ/shapes/InfiniteState.h>
#endif
#ifndef INCLUDED_differ_shapes_Polygon
#include <hxinc/differ/shapes/Polygon.h>
#endif
#ifndef INCLUDED_differ_shapes_Ray
#include <hxinc/differ/shapes/Ray.h>
#endif
#ifndef INCLUDED_differ_shapes_Shape
#include <hxinc/differ/shapes/Shape.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_13_testCircleVsPolygon,"differ.sat.SAT2D","testCircleVsPolygon",0x4249be41,"differ.sat.SAT2D.testCircleVsPolygon","differ/sat/SAT2D.hx",13,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_143_testCircleVsCircle,"differ.sat.SAT2D","testCircleVsCircle",0x70ab8c29,"differ.sat.SAT2D.testCircleVsCircle","differ/sat/SAT2D.hx",143,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_191_testPolygonVsPolygon,"differ.sat.SAT2D","testPolygonVsPolygon",0x352d52af,"differ.sat.SAT2D.testPolygonVsPolygon","differ/sat/SAT2D.hx",191,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_226_testRayVsCircle,"differ.sat.SAT2D","testRayVsCircle",0xa499b8eb,"differ.sat.SAT2D.testRayVsCircle","differ/sat/SAT2D.hx",226,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_271_testRayVsPolygon,"differ.sat.SAT2D","testRayVsPolygon",0x7ec2bb3f,"differ.sat.SAT2D.testRayVsPolygon","differ/sat/SAT2D.hx",271,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_330_testRayVsRay,"differ.sat.SAT2D","testRayVsRay",0xf1a1882f,"differ.sat.SAT2D.testRayVsRay","differ/sat/SAT2D.hx",330,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_378_checkPolygons,"differ.sat.SAT2D","checkPolygons",0x49a04707,"differ.sat.SAT2D.checkPolygons","differ/sat/SAT2D.hx",378,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_456_rayU,"differ.sat.SAT2D","rayU",0x78255a85,"differ.sat.SAT2D.rayU","differ/sat/SAT2D.hx",456,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_459_findNormalAxisX,"differ.sat.SAT2D","findNormalAxisX",0x646e581d,"differ.sat.SAT2D.findNormalAxisX","differ/sat/SAT2D.hx",459,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_464_findNormalAxisY,"differ.sat.SAT2D","findNormalAxisY",0x646e581e,"differ.sat.SAT2D.findNormalAxisY","differ/sat/SAT2D.hx",464,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_188_boot,"differ.sat.SAT2D","boot",0x6d9c878c,"differ.sat.SAT2D.boot","differ/sat/SAT2D.hx",188,0x35f7da6c)
HX_LOCAL_STACK_FRAME(_hx_pos_f57fec11f82d7dd3_189_boot,"differ.sat.SAT2D","boot",0x6d9c878c,"differ.sat.SAT2D.boot","differ/sat/SAT2D.hx",189,0x35f7da6c)
namespace differ{
namespace sat{

void SAT2D_obj::__construct() { }

Dynamic SAT2D_obj::__CreateEmpty() { return new SAT2D_obj; }

void *SAT2D_obj::_hx_vtable = 0;

Dynamic SAT2D_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< SAT2D_obj > _hx_result = new SAT2D_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SAT2D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x602a80a4;
}

 ::differ::data::ShapeCollision SAT2D_obj::testCircleVsPolygon( ::differ::shapes::Circle circle, ::differ::shapes::Polygon polygon, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_13_testCircleVsPolygon)
HXLINE(  15)		if (hx::IsNull( into )) {
HXLINE(  15)			into =  ::differ::data::ShapeCollision_obj::__alloc( HX_CTX );
            		}
            		else {
HXLINE(  15)			into->_hx_set_shape1(HX_CTX, (into->_hx_set_shape2(HX_CTX, null())));
HXDLIN(  15)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN(  15)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN(  15)			into = into;
            		}
HXLINE(  17)		::Array< ::Dynamic> verts = polygon->get_transformedVertices();
HXLINE(  19)		Float circleX = circle->get_x();
HXLINE(  20)		Float circleY = circle->get_y();
HXLINE(  22)		Float testDistance = ( (Float)((int)1073741823) );
HXLINE(  23)		Float distance = ((Float)0.0);
HXDLIN(  23)		Float closestX = ((Float)0.0);
HXDLIN(  23)		Float closestY = ((Float)0.0);
HXLINE(  24)		{
HXLINE(  24)			int _g = 0;
HXDLIN(  24)			int _g1 = verts->length;
HXDLIN(  24)			while((_g < _g1)){
HXLINE(  24)				_g = (_g + 1);
HXDLIN(  24)				int i = (_g - 1);
HXLINE(  26)				Float x = (circleX - verts->__get(i).StaticCast<  ::differ::math::Vector >()->x);
HXDLIN(  26)				Float y = (circleY - verts->__get(i).StaticCast<  ::differ::math::Vector >()->y);
HXDLIN(  26)				distance = ((x * x) + (y * y));
HXLINE(  28)				if ((distance < testDistance)) {
HXLINE(  29)					testDistance = distance;
HXLINE(  30)					closestX = verts->__get(i).StaticCast<  ::differ::math::Vector >()->x;
HXLINE(  31)					closestY = verts->__get(i).StaticCast<  ::differ::math::Vector >()->y;
            				}
            			}
            		}
HXLINE(  36)		Float normalAxisX = (closestX - circleX);
HXLINE(  37)		Float normalAxisY = (closestY - circleY);
HXLINE(  38)		Float normAxisLen = ::Math_obj::sqrt(((normalAxisX * normalAxisX) + (normalAxisY * normalAxisY)));
HXLINE(  39)		Float component = normalAxisX;
HXDLIN(  39)		if ((normAxisLen == 0)) {
HXLINE(  39)			normalAxisX = ( (Float)(0) );
            		}
            		else {
HXLINE(  39)			component = (component / normAxisLen);
HXDLIN(  39)			normalAxisX = component;
            		}
HXLINE(  40)		Float component1 = normalAxisY;
HXDLIN(  40)		if ((normAxisLen == 0)) {
HXLINE(  40)			normalAxisY = ( (Float)(0) );
            		}
            		else {
HXLINE(  40)			component1 = (component1 / normAxisLen);
HXDLIN(  40)			normalAxisY = component1;
            		}
HXLINE(  43)		Float test = ((Float)0.0);
HXLINE(  44)		Float min1 = ((normalAxisX * verts->__get(0).StaticCast<  ::differ::math::Vector >()->x) + (normalAxisY * verts->__get(0).StaticCast<  ::differ::math::Vector >()->y));
HXLINE(  45)		Float max1 = min1;
HXLINE(  47)		{
HXLINE(  47)			int _g2 = 1;
HXDLIN(  47)			int _g3 = verts->length;
HXDLIN(  47)			while((_g2 < _g3)){
HXLINE(  47)				_g2 = (_g2 + 1);
HXDLIN(  47)				int j = (_g2 - 1);
HXLINE(  48)				test = ((normalAxisX * verts->__get(j).StaticCast<  ::differ::math::Vector >()->x) + (normalAxisY * verts->__get(j).StaticCast<  ::differ::math::Vector >()->y));
HXLINE(  49)				if ((test < min1)) {
HXLINE(  49)					min1 = test;
            				}
HXLINE(  50)				if ((test > max1)) {
HXLINE(  50)					max1 = test;
            				}
            			}
            		}
HXLINE(  54)		Float max2 = circle->get_transformedRadius();
HXLINE(  55)		Float min2 = -(circle->get_transformedRadius());
HXLINE(  56)		Float offset = ((normalAxisX * -(circleX)) + (normalAxisY * -(circleY)));
HXLINE(  58)		min1 = (min1 + offset);
HXLINE(  59)		max1 = (max1 + offset);
HXLINE(  61)		Float test1 = (min1 - max2);
HXLINE(  62)		Float test2 = (min2 - max1);
HXLINE(  65)		bool _hx_tmp;
HXDLIN(  65)		if (!((test1 > 0))) {
HXLINE(  65)			_hx_tmp = (test2 > 0);
            		}
            		else {
HXLINE(  65)			_hx_tmp = true;
            		}
HXDLIN(  65)		if (_hx_tmp) {
HXLINE(  65)			return null();
            		}
HXLINE(  68)		Float distMin = -((max2 - min1));
HXLINE(  69)		if (flip) {
HXLINE(  69)			distMin = (distMin * ( (Float)(-1) ));
            		}
HXLINE(  71)		into->overlap = distMin;
HXLINE(  72)		into->unitVectorX = normalAxisX;
HXLINE(  73)		into->unitVectorY = normalAxisY;
HXLINE(  74)		Float closest = ::Math_obj::abs(distMin);
HXLINE(  77)		{
HXLINE(  77)			int _g4 = 0;
HXDLIN(  77)			int _g5 = verts->length;
HXDLIN(  77)			while((_g4 < _g5)){
HXLINE(  77)				_g4 = (_g4 + 1);
HXDLIN(  77)				int i1 = (_g4 - 1);
HXLINE(  79)				 ::differ::math::Vector v2;
HXDLIN(  79)				if ((i1 >= (verts->length - 1))) {
HXLINE(  79)					v2 = verts->__get(0).StaticCast<  ::differ::math::Vector >();
            				}
            				else {
HXLINE(  79)					v2 = verts->__get((i1 + 1)).StaticCast<  ::differ::math::Vector >();
            				}
HXDLIN(  79)				normalAxisX = -((v2->y - verts->__get(i1).StaticCast<  ::differ::math::Vector >()->y));
HXLINE(  80)				 ::differ::math::Vector v21;
HXDLIN(  80)				if ((i1 >= (verts->length - 1))) {
HXLINE(  80)					v21 = verts->__get(0).StaticCast<  ::differ::math::Vector >();
            				}
            				else {
HXLINE(  80)					v21 = verts->__get((i1 + 1)).StaticCast<  ::differ::math::Vector >();
            				}
HXDLIN(  80)				normalAxisY = (v21->x - verts->__get(i1).StaticCast<  ::differ::math::Vector >()->x);
HXLINE(  81)				Float aLen = ::Math_obj::sqrt(((normalAxisX * normalAxisX) + (normalAxisY * normalAxisY)));
HXLINE(  82)				Float component2 = normalAxisX;
HXDLIN(  82)				if ((aLen == 0)) {
HXLINE(  82)					normalAxisX = ( (Float)(0) );
            				}
            				else {
HXLINE(  82)					component2 = (component2 / aLen);
HXDLIN(  82)					normalAxisX = component2;
            				}
HXLINE(  83)				Float component3 = normalAxisY;
HXDLIN(  83)				if ((aLen == 0)) {
HXLINE(  83)					normalAxisY = ( (Float)(0) );
            				}
            				else {
HXLINE(  83)					component3 = (component3 / aLen);
HXDLIN(  83)					normalAxisY = component3;
            				}
HXLINE(  86)				min1 = ((normalAxisX * verts->__get(0).StaticCast<  ::differ::math::Vector >()->x) + (normalAxisY * verts->__get(0).StaticCast<  ::differ::math::Vector >()->y));
HXLINE(  87)				max1 = min1;
HXLINE(  90)				{
HXLINE(  90)					int _g41 = 1;
HXDLIN(  90)					int _g51 = verts->length;
HXDLIN(  90)					while((_g41 < _g51)){
HXLINE(  90)						_g41 = (_g41 + 1);
HXDLIN(  90)						int j1 = (_g41 - 1);
HXLINE(  91)						test = ((normalAxisX * verts->__get(j1).StaticCast<  ::differ::math::Vector >()->x) + (normalAxisY * verts->__get(j1).StaticCast<  ::differ::math::Vector >()->y));
HXLINE(  92)						if ((test < min1)) {
HXLINE(  92)							min1 = test;
            						}
HXLINE(  93)						if ((test > max1)) {
HXLINE(  93)							max1 = test;
            						}
            					}
            				}
HXLINE(  97)				max2 = circle->get_transformedRadius();
HXLINE(  98)				min2 = -(circle->get_transformedRadius());
HXLINE( 101)				offset = ((normalAxisX * -(circleX)) + (normalAxisY * -(circleY)));
HXLINE( 102)				min1 = (min1 + offset);
HXLINE( 103)				max1 = (max1 + offset);
HXLINE( 106)				test1 = (min1 - max2);
HXLINE( 107)				test2 = (min2 - max1);
HXLINE( 110)				bool _hx_tmp1;
HXDLIN( 110)				if (!((test1 > 0))) {
HXLINE( 110)					_hx_tmp1 = (test2 > 0);
            				}
            				else {
HXLINE( 110)					_hx_tmp1 = true;
            				}
HXDLIN( 110)				if (_hx_tmp1) {
HXLINE( 111)					return null();
            				}
HXLINE( 114)				distMin = -((max2 - min1));
HXLINE( 115)				if (flip) {
HXLINE( 115)					distMin = (distMin * ( (Float)(-1) ));
            				}
HXLINE( 117)				if ((::Math_obj::abs(distMin) < closest)) {
HXLINE( 118)					into->unitVectorX = normalAxisX;
HXLINE( 119)					into->unitVectorY = normalAxisY;
HXLINE( 120)					into->overlap = distMin;
HXLINE( 121)					closest = ::Math_obj::abs(distMin);
            				}
            			}
            		}
HXLINE( 128)		 ::differ::shapes::Shape _hx_tmp2;
HXDLIN( 128)		if (flip) {
HXLINE( 128)			_hx_tmp2 = polygon;
            		}
            		else {
HXLINE( 128)			_hx_tmp2 = circle;
            		}
HXDLIN( 128)		into->_hx_set_shape1(HX_CTX, _hx_tmp2);
HXLINE( 129)		 ::differ::shapes::Shape _hx_tmp3;
HXDLIN( 129)		if (flip) {
HXLINE( 129)			_hx_tmp3 = circle;
            		}
            		else {
HXLINE( 129)			_hx_tmp3 = polygon;
            		}
HXDLIN( 129)		into->_hx_set_shape2(HX_CTX, _hx_tmp3);
HXLINE( 130)		into->separationX = (into->unitVectorX * into->overlap);
HXLINE( 131)		into->separationY = (into->unitVectorY * into->overlap);
HXLINE( 133)		if (!(flip)) {
HXLINE( 134)			into->unitVectorX = -(into->unitVectorX);
HXLINE( 135)			into->unitVectorY = -(into->unitVectorY);
            		}
HXLINE( 138)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testCircleVsPolygon,return )

 ::differ::data::ShapeCollision SAT2D_obj::testCircleVsCircle( ::differ::shapes::Circle circleA, ::differ::shapes::Circle circleB, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_143_testCircleVsCircle)
HXLINE( 146)		 ::differ::shapes::Circle circle1;
HXDLIN( 146)		if (flip) {
HXLINE( 146)			circle1 = circleB;
            		}
            		else {
HXLINE( 146)			circle1 = circleA;
            		}
HXLINE( 147)		 ::differ::shapes::Circle circle2;
HXDLIN( 147)		if (flip) {
HXLINE( 147)			circle2 = circleA;
            		}
            		else {
HXLINE( 147)			circle2 = circleB;
            		}
HXLINE( 150)		Float totalRadius = circle1->get_transformedRadius();
HXDLIN( 150)		Float totalRadius1 = (totalRadius + circle2->get_transformedRadius());
HXLINE( 152)		Float x = circle1->get_x();
HXDLIN( 152)		Float x1 = (x - circle2->get_x());
HXDLIN( 152)		Float y = circle1->get_y();
HXDLIN( 152)		Float y1 = (y - circle2->get_y());
HXDLIN( 152)		Float distancesq = ((x1 * x1) + (y1 * y1));
HXLINE( 155)		if ((distancesq < (totalRadius1 * totalRadius1))) {
HXLINE( 157)			if (hx::IsNull( into )) {
HXLINE( 157)				into =  ::differ::data::ShapeCollision_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 157)				into->_hx_set_shape1(HX_CTX, (into->_hx_set_shape2(HX_CTX, null())));
HXDLIN( 157)				into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 157)				into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN( 157)				into = into;
            			}
HXLINE( 159)			Float difference = (totalRadius1 - ::Math_obj::sqrt(distancesq));
HXLINE( 161)			into->_hx_set_shape1(HX_CTX, circle1);
HXLINE( 162)			into->_hx_set_shape2(HX_CTX, circle2);
HXLINE( 164)			Float unitVecX = circle1->get_x();
HXDLIN( 164)			Float unitVecX1 = (unitVecX - circle2->get_x());
HXLINE( 165)			Float unitVecY = circle1->get_y();
HXDLIN( 165)			Float unitVecY1 = (unitVecY - circle2->get_y());
HXLINE( 166)			Float unitVecLen = ::Math_obj::sqrt(((unitVecX1 * unitVecX1) + (unitVecY1 * unitVecY1)));
HXLINE( 168)			Float component = unitVecX1;
HXDLIN( 168)			if ((unitVecLen == 0)) {
HXLINE( 168)				unitVecX1 = ( (Float)(0) );
            			}
            			else {
HXLINE( 168)				component = (component / unitVecLen);
HXDLIN( 168)				unitVecX1 = component;
            			}
HXLINE( 169)			Float component1 = unitVecY1;
HXDLIN( 169)			if ((unitVecLen == 0)) {
HXLINE( 169)				unitVecY1 = ( (Float)(0) );
            			}
            			else {
HXLINE( 169)				component1 = (component1 / unitVecLen);
HXDLIN( 169)				unitVecY1 = component1;
            			}
HXLINE( 171)			into->unitVectorX = unitVecX1;
HXLINE( 172)			into->unitVectorY = unitVecY1;
HXLINE( 175)			into->separationX = (into->unitVectorX * difference);
HXLINE( 176)			into->separationY = (into->unitVectorY * difference);
HXLINE( 177)			into->overlap = difference;
HXLINE( 179)			return into;
            		}
HXLINE( 183)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testCircleVsCircle,return )

 ::differ::data::ShapeCollision SAT2D_obj::tmp1;

 ::differ::data::ShapeCollision SAT2D_obj::tmp2;

 ::differ::data::ShapeCollision SAT2D_obj::testPolygonVsPolygon( ::differ::shapes::Polygon polygon1, ::differ::shapes::Polygon polygon2, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_191_testPolygonVsPolygon)
HXLINE( 193)		if (hx::IsNull( into )) {
HXLINE( 193)			into =  ::differ::data::ShapeCollision_obj::__alloc( HX_CTX );
            		}
            		else {
HXLINE( 193)			into->_hx_set_shape1(HX_CTX, (into->_hx_set_shape2(HX_CTX, null())));
HXDLIN( 193)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 193)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN( 193)			into = into;
            		}
HXLINE( 195)		if (hx::IsNull( ::differ::sat::SAT2D_obj::checkPolygons(polygon1,polygon2,::differ::sat::SAT2D_obj::tmp1,flip) )) {
HXLINE( 196)			return null();
            		}
HXLINE( 199)		if (hx::IsNull( ::differ::sat::SAT2D_obj::checkPolygons(polygon2,polygon1,::differ::sat::SAT2D_obj::tmp2,!(flip)) )) {
HXLINE( 200)			return null();
            		}
HXLINE( 203)		 ::differ::data::ShapeCollision result = null();
HXDLIN( 203)		 ::differ::data::ShapeCollision other = null();
HXLINE( 204)		if ((::Math_obj::abs(::differ::sat::SAT2D_obj::tmp1->overlap) < ::Math_obj::abs(::differ::sat::SAT2D_obj::tmp2->overlap))) {
HXLINE( 205)			result = ::differ::sat::SAT2D_obj::tmp1;
HXLINE( 206)			other = ::differ::sat::SAT2D_obj::tmp2;
            		}
            		else {
HXLINE( 208)			result = ::differ::sat::SAT2D_obj::tmp2;
HXLINE( 209)			other = ::differ::sat::SAT2D_obj::tmp1;
            		}
HXLINE( 212)		result->otherOverlap = other->overlap;
HXLINE( 213)		result->otherSeparationX = other->separationX;
HXLINE( 214)		result->otherSeparationY = other->separationY;
HXLINE( 215)		result->otherUnitVectorX = other->unitVectorX;
HXLINE( 216)		result->otherUnitVectorY = other->unitVectorY;
HXLINE( 218)		{
HXLINE( 218)			into->overlap = result->overlap;
HXDLIN( 218)			into->separationX = result->separationX;
HXDLIN( 218)			into->separationY = result->separationY;
HXDLIN( 218)			into->unitVectorX = result->unitVectorX;
HXDLIN( 218)			into->unitVectorY = result->unitVectorY;
HXDLIN( 218)			into->otherOverlap = result->otherOverlap;
HXDLIN( 218)			into->otherSeparationX = result->otherSeparationX;
HXDLIN( 218)			into->otherSeparationY = result->otherSeparationY;
HXDLIN( 218)			into->otherUnitVectorX = result->otherUnitVectorX;
HXDLIN( 218)			into->otherUnitVectorY = result->otherUnitVectorY;
HXDLIN( 218)			into->_hx_set_shape1(HX_CTX, result->shape1);
HXDLIN( 218)			into->_hx_set_shape2(HX_CTX, result->shape2);
            		}
HXLINE( 219)		other = null();
HXDLIN( 219)		result = other;
HXLINE( 221)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testPolygonVsPolygon,return )

 ::differ::data::RayCollision SAT2D_obj::testRayVsCircle( ::differ::shapes::Ray ray, ::differ::shapes::Circle circle, ::differ::data::RayCollision into){
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_226_testRayVsCircle)
HXLINE( 228)		Float deltaX = (ray->end->x - ray->start->x);
HXLINE( 229)		Float deltaY = (ray->end->y - ray->start->y);
HXLINE( 230)		Float ray1 = ray->start->x;
HXDLIN( 230)		Float ray2circleX = (ray1 - circle->get_position()->x);
HXLINE( 231)		Float ray2 = ray->start->y;
HXDLIN( 231)		Float ray2circleY = (ray2 - circle->get_position()->y);
HXLINE( 233)		Float a = ((deltaX * deltaX) + (deltaY * deltaY));
HXLINE( 234)		Float b = (( (Float)(2) ) * ((deltaX * ray2circleX) + (deltaY * ray2circleY)));
HXLINE( 235)		Float c = circle->get_radius();
HXDLIN( 235)		Float c1 = (((ray2circleX * ray2circleX) + (ray2circleY * ray2circleY)) - (c * circle->get_radius()));
HXLINE( 236)		Float d = ((b * b) - ((( (Float)(4) ) * a) * c1));
HXLINE( 238)		if ((d >= 0)) {
HXLINE( 240)			d = ::Math_obj::sqrt(d);
HXLINE( 242)			Float t1 = ((-(b) - d) / (( (Float)(2) ) * a));
HXLINE( 243)			Float t2 = ((-(b) + d) / (( (Float)(2) ) * a));
HXLINE( 245)			bool valid;
HXDLIN( 245)			switch((int)(ray->infinite->_hx_getIndex())){
            				case (int)0: {
HXLINE( 246)					if ((t1 >= ((Float)0.0))) {
HXLINE( 245)						valid = (t1 <= ((Float)1.0));
            					}
            					else {
HXLINE( 245)						valid = false;
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 245)					valid = (t1 >= ((Float)0.0));
            				}
            				break;
            				case (int)2: {
HXLINE( 245)					valid = true;
            				}
            				break;
            			}
HXLINE( 251)			if (valid) {
HXLINE( 253)				if (hx::IsNull( into )) {
HXLINE( 253)					into =  ::differ::data::RayCollision_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 253)					into->_hx_set_ray(HX_CTX, null());
HXDLIN( 253)					into->_hx_set_shape(HX_CTX, null());
HXDLIN( 253)					into->start = ((Float)0.0);
HXDLIN( 253)					into->end = ((Float)0.0);
HXDLIN( 253)					into = into;
            				}
HXLINE( 255)				into->_hx_set_shape(HX_CTX, circle);
HXLINE( 256)				into->_hx_set_ray(HX_CTX, ray);
HXLINE( 257)				into->start = t1;
HXLINE( 258)				into->end = t2;
HXLINE( 260)				return into;
            			}
            		}
HXLINE( 266)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsCircle,return )

 ::differ::data::RayCollision SAT2D_obj::testRayVsPolygon( ::differ::shapes::Ray ray, ::differ::shapes::Polygon polygon, ::differ::data::RayCollision into){
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_271_testRayVsPolygon)
HXLINE( 273)		Float min_u = ::Math_obj::POSITIVE_INFINITY;
HXLINE( 274)		Float max_u = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 276)		Float startX = ray->start->x;
HXLINE( 277)		Float startY = ray->start->y;
HXLINE( 278)		Float deltaX = (ray->end->x - startX);
HXLINE( 279)		Float deltaY = (ray->end->y - startY);
HXLINE( 281)		::Array< ::Dynamic> verts = polygon->get_transformedVertices();
HXLINE( 282)		 ::differ::math::Vector v1 = verts->__get((verts->length - 1)).StaticCast<  ::differ::math::Vector >();
HXLINE( 283)		 ::differ::math::Vector v2 = verts->__get(0).StaticCast<  ::differ::math::Vector >();
HXLINE( 285)		Float ud = (((v2->y - v1->y) * deltaX) - ((v2->x - v1->x) * deltaY));
HXLINE( 286)		Float ua = ((((v2->x - v1->x) * (startY - v1->y)) - ((v2->y - v1->y) * (startX - v1->x))) / ud);
HXLINE( 287)		Float ub = (((deltaX * (startY - v1->y)) - (deltaY * (startX - v1->x))) / ud);
HXLINE( 289)		bool _hx_tmp;
HXDLIN( 289)		bool _hx_tmp1;
HXDLIN( 289)		if ((ud != ((Float)0.0))) {
HXLINE( 289)			_hx_tmp1 = (ub >= ((Float)0.0));
            		}
            		else {
HXLINE( 289)			_hx_tmp1 = false;
            		}
HXDLIN( 289)		if (_hx_tmp1) {
HXLINE( 289)			_hx_tmp = (ub <= ((Float)1.0));
            		}
            		else {
HXLINE( 289)			_hx_tmp = false;
            		}
HXDLIN( 289)		if (_hx_tmp) {
HXLINE( 290)			if ((ua < min_u)) {
HXLINE( 290)				min_u = ua;
            			}
HXLINE( 291)			if ((ua > max_u)) {
HXLINE( 291)				max_u = ua;
            			}
            		}
HXLINE( 294)		{
HXLINE( 294)			int _g = 1;
HXDLIN( 294)			int _g1 = verts->length;
HXDLIN( 294)			while((_g < _g1)){
HXLINE( 294)				_g = (_g + 1);
HXDLIN( 294)				int i = (_g - 1);
HXLINE( 296)				v1 = verts->__get((i - 1)).StaticCast<  ::differ::math::Vector >();
HXLINE( 297)				v2 = verts->__get(i).StaticCast<  ::differ::math::Vector >();
HXLINE( 299)				ud = (((v2->y - v1->y) * deltaX) - ((v2->x - v1->x) * deltaY));
HXLINE( 300)				ua = ((((v2->x - v1->x) * (startY - v1->y)) - ((v2->y - v1->y) * (startX - v1->x))) / ud);
HXLINE( 301)				ub = (((deltaX * (startY - v1->y)) - (deltaY * (startX - v1->x))) / ud);
HXLINE( 303)				bool _hx_tmp2;
HXDLIN( 303)				bool _hx_tmp3;
HXDLIN( 303)				if ((ud != ((Float)0.0))) {
HXLINE( 303)					_hx_tmp3 = (ub >= ((Float)0.0));
            				}
            				else {
HXLINE( 303)					_hx_tmp3 = false;
            				}
HXDLIN( 303)				if (_hx_tmp3) {
HXLINE( 303)					_hx_tmp2 = (ub <= ((Float)1.0));
            				}
            				else {
HXLINE( 303)					_hx_tmp2 = false;
            				}
HXDLIN( 303)				if (_hx_tmp2) {
HXLINE( 304)					if ((ua < min_u)) {
HXLINE( 304)						min_u = ua;
            					}
HXLINE( 305)					if ((ua > max_u)) {
HXLINE( 305)						max_u = ua;
            					}
            				}
            			}
            		}
HXLINE( 310)		bool valid;
HXDLIN( 310)		switch((int)(ray->infinite->_hx_getIndex())){
            			case (int)0: {
HXLINE( 311)				if ((min_u >= ((Float)0.0))) {
HXLINE( 310)					valid = (min_u <= ((Float)1.0));
            				}
            				else {
HXLINE( 310)					valid = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 312)				if ((min_u != ::Math_obj::POSITIVE_INFINITY)) {
HXLINE( 310)					valid = (min_u >= ((Float)0.0));
            				}
            				else {
HXLINE( 310)					valid = false;
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 310)				valid = (min_u != ::Math_obj::POSITIVE_INFINITY);
            			}
            			break;
            		}
HXLINE( 316)		if (valid) {
HXLINE( 317)			if (hx::IsNull( into )) {
HXLINE( 317)				into =  ::differ::data::RayCollision_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 317)				into->_hx_set_ray(HX_CTX, null());
HXDLIN( 317)				into->_hx_set_shape(HX_CTX, null());
HXDLIN( 317)				into->start = ((Float)0.0);
HXDLIN( 317)				into->end = ((Float)0.0);
HXDLIN( 317)				into = into;
            			}
HXLINE( 318)			into->_hx_set_shape(HX_CTX, polygon);
HXLINE( 319)			into->_hx_set_ray(HX_CTX, ray);
HXLINE( 320)			into->start = min_u;
HXLINE( 321)			into->end = max_u;
HXLINE( 322)			return into;
            		}
HXLINE( 325)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsPolygon,return )

 ::differ::data::RayIntersection SAT2D_obj::testRayVsRay( ::differ::shapes::Ray ray1, ::differ::shapes::Ray ray2, ::differ::data::RayIntersection into){
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_330_testRayVsRay)
HXLINE( 332)		Float delta1X = (ray1->end->x - ray1->start->x);
HXLINE( 333)		Float delta1Y = (ray1->end->y - ray1->start->y);
HXLINE( 334)		Float delta2X = (ray2->end->x - ray2->start->x);
HXLINE( 335)		Float delta2Y = (ray2->end->y - ray2->start->y);
HXLINE( 336)		Float diffX = (ray1->start->x - ray2->start->x);
HXLINE( 337)		Float diffY = (ray1->start->y - ray2->start->y);
HXLINE( 338)		Float ud = ((delta2Y * delta1X) - (delta2X * delta1Y));
HXLINE( 340)		if ((ud == ((Float)0.0))) {
HXLINE( 340)			return null();
            		}
HXLINE( 342)		Float u1 = (((delta2X * diffY) - (delta2Y * diffX)) / ud);
HXLINE( 343)		Float u2 = (((delta1X * diffY) - (delta1Y * diffX)) / ud);
HXLINE( 346)		bool valid1;
HXDLIN( 346)		switch((int)(ray1->infinite->_hx_getIndex())){
            			case (int)0: {
HXLINE( 347)				if ((u1 > ((Float)0.0))) {
HXLINE( 346)					valid1 = (u1 <= ((Float)1.0));
            				}
            				else {
HXLINE( 346)					valid1 = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 346)				valid1 = (u1 > ((Float)0.0));
            			}
            			break;
            			case (int)2: {
HXLINE( 346)				valid1 = true;
            			}
            			break;
            		}
HXLINE( 352)		bool valid2;
HXDLIN( 352)		switch((int)(ray2->infinite->_hx_getIndex())){
            			case (int)0: {
HXLINE( 353)				if ((u2 > ((Float)0.0))) {
HXLINE( 352)					valid2 = (u2 <= ((Float)1.0));
            				}
            				else {
HXLINE( 352)					valid2 = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 352)				valid2 = (u2 > ((Float)0.0));
            			}
            			break;
            			case (int)2: {
HXLINE( 352)				valid2 = true;
            			}
            			break;
            		}
HXLINE( 358)		bool _hx_tmp;
HXDLIN( 358)		if (valid1) {
HXLINE( 358)			_hx_tmp = valid2;
            		}
            		else {
HXLINE( 358)			_hx_tmp = false;
            		}
HXDLIN( 358)		if (_hx_tmp) {
HXLINE( 360)			if (hx::IsNull( into )) {
HXLINE( 360)				into =  ::differ::data::RayIntersection_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 360)				into->_hx_set_ray1(HX_CTX, null());
HXDLIN( 360)				into->_hx_set_ray2(HX_CTX, null());
HXDLIN( 360)				into->u1 = ((Float)0.0);
HXDLIN( 360)				into->u2 = ((Float)0.0);
HXDLIN( 360)				into = into;
            			}
HXLINE( 362)			into->_hx_set_ray1(HX_CTX, ray1);
HXLINE( 363)			into->_hx_set_ray2(HX_CTX, ray2);
HXLINE( 364)			into->u1 = u1;
HXLINE( 365)			into->u2 = u2;
HXLINE( 367)			return into;
            		}
HXLINE( 371)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsRay,return )

 ::differ::data::ShapeCollision SAT2D_obj::checkPolygons( ::differ::shapes::Polygon polygon1, ::differ::shapes::Polygon polygon2, ::differ::data::ShapeCollision into,hx::Null< bool >  __o_flip){
            		bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_378_checkPolygons)
HXLINE( 380)		{
HXLINE( 380)			into->_hx_set_shape1(HX_CTX, (into->_hx_set_shape2(HX_CTX, null())));
HXDLIN( 380)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 380)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
            		}
HXLINE( 382)		Float offset = ((Float)0.0);
HXDLIN( 382)		Float test1 = ((Float)0.0);
HXDLIN( 382)		Float test2 = ((Float)0.0);
HXDLIN( 382)		Float testNum = ((Float)0.0);
HXLINE( 383)		Float min1 = ((Float)0.0);
HXDLIN( 383)		Float max1 = ((Float)0.0);
HXDLIN( 383)		Float min2 = ((Float)0.0);
HXDLIN( 383)		Float max2 = ((Float)0.0);
HXLINE( 384)		Float closest = ( (Float)((int)1073741823) );
HXLINE( 386)		Float axisX = ((Float)0.0);
HXLINE( 387)		Float axisY = ((Float)0.0);
HXLINE( 388)		::Array< ::Dynamic> verts1 = polygon1->get_transformedVertices();
HXLINE( 389)		::Array< ::Dynamic> verts2 = polygon2->get_transformedVertices();
HXLINE( 392)		{
HXLINE( 392)			int _g = 0;
HXDLIN( 392)			int _g1 = verts1->length;
HXDLIN( 392)			while((_g < _g1)){
HXLINE( 392)				_g = (_g + 1);
HXDLIN( 392)				int i = (_g - 1);
HXLINE( 394)				 ::differ::math::Vector v2;
HXDLIN( 394)				if ((i >= (verts1->length - 1))) {
HXLINE( 394)					v2 = verts1->__get(0).StaticCast<  ::differ::math::Vector >();
            				}
            				else {
HXLINE( 394)					v2 = verts1->__get((i + 1)).StaticCast<  ::differ::math::Vector >();
            				}
HXDLIN( 394)				axisX = -((v2->y - verts1->__get(i).StaticCast<  ::differ::math::Vector >()->y));
HXLINE( 395)				 ::differ::math::Vector v21;
HXDLIN( 395)				if ((i >= (verts1->length - 1))) {
HXLINE( 395)					v21 = verts1->__get(0).StaticCast<  ::differ::math::Vector >();
            				}
            				else {
HXLINE( 395)					v21 = verts1->__get((i + 1)).StaticCast<  ::differ::math::Vector >();
            				}
HXDLIN( 395)				axisY = (v21->x - verts1->__get(i).StaticCast<  ::differ::math::Vector >()->x);
HXLINE( 396)				Float aLen = ::Math_obj::sqrt(((axisX * axisX) + (axisY * axisY)));
HXLINE( 397)				Float component = axisX;
HXDLIN( 397)				if ((aLen == 0)) {
HXLINE( 397)					axisX = ( (Float)(0) );
            				}
            				else {
HXLINE( 397)					component = (component / aLen);
HXDLIN( 397)					axisX = component;
            				}
HXLINE( 398)				Float component1 = axisY;
HXDLIN( 398)				if ((aLen == 0)) {
HXLINE( 398)					axisY = ( (Float)(0) );
            				}
            				else {
HXLINE( 398)					component1 = (component1 / aLen);
HXDLIN( 398)					axisY = component1;
            				}
HXLINE( 401)				min1 = ((axisX * verts1->__get(0).StaticCast<  ::differ::math::Vector >()->x) + (axisY * verts1->__get(0).StaticCast<  ::differ::math::Vector >()->y));
HXLINE( 402)				max1 = min1;
HXLINE( 404)				{
HXLINE( 404)					int _g2 = 1;
HXDLIN( 404)					int _g11 = verts1->length;
HXDLIN( 404)					while((_g2 < _g11)){
HXLINE( 404)						_g2 = (_g2 + 1);
HXDLIN( 404)						int j = (_g2 - 1);
HXLINE( 405)						testNum = ((axisX * verts1->__get(j).StaticCast<  ::differ::math::Vector >()->x) + (axisY * verts1->__get(j).StaticCast<  ::differ::math::Vector >()->y));
HXLINE( 406)						if ((testNum < min1)) {
HXLINE( 406)							min1 = testNum;
            						}
HXLINE( 407)						if ((testNum > max1)) {
HXLINE( 407)							max1 = testNum;
            						}
            					}
            				}
HXLINE( 411)				min2 = ((axisX * verts2->__get(0).StaticCast<  ::differ::math::Vector >()->x) + (axisY * verts2->__get(0).StaticCast<  ::differ::math::Vector >()->y));
HXLINE( 412)				max2 = min2;
HXLINE( 414)				{
HXLINE( 414)					int _g21 = 1;
HXDLIN( 414)					int _g3 = verts2->length;
HXDLIN( 414)					while((_g21 < _g3)){
HXLINE( 414)						_g21 = (_g21 + 1);
HXDLIN( 414)						int j1 = (_g21 - 1);
HXLINE( 415)						testNum = ((axisX * verts2->__get(j1).StaticCast<  ::differ::math::Vector >()->x) + (axisY * verts2->__get(j1).StaticCast<  ::differ::math::Vector >()->y));
HXLINE( 416)						if ((testNum < min2)) {
HXLINE( 416)							min2 = testNum;
            						}
HXLINE( 417)						if ((testNum > max2)) {
HXLINE( 417)							max2 = testNum;
            						}
            					}
            				}
HXLINE( 420)				test1 = (min1 - max2);
HXLINE( 421)				test2 = (min2 - max1);
HXLINE( 423)				bool _hx_tmp;
HXDLIN( 423)				if (!((test1 > 0))) {
HXLINE( 423)					_hx_tmp = (test2 > 0);
            				}
            				else {
HXLINE( 423)					_hx_tmp = true;
            				}
HXDLIN( 423)				if (_hx_tmp) {
HXLINE( 423)					return null();
            				}
HXLINE( 425)				Float distMin = -((max2 - min1));
HXLINE( 426)				if (flip) {
HXLINE( 426)					distMin = (distMin * ( (Float)(-1) ));
            				}
HXLINE( 428)				if ((::Math_obj::abs(distMin) < closest)) {
HXLINE( 429)					into->unitVectorX = axisX;
HXLINE( 430)					into->unitVectorY = axisY;
HXLINE( 431)					into->overlap = distMin;
HXLINE( 432)					closest = ::Math_obj::abs(distMin);
            				}
            			}
            		}
HXLINE( 437)		 ::differ::shapes::Shape _hx_tmp1;
HXDLIN( 437)		if (flip) {
HXLINE( 437)			_hx_tmp1 = polygon2;
            		}
            		else {
HXLINE( 437)			_hx_tmp1 = polygon1;
            		}
HXDLIN( 437)		into->_hx_set_shape1(HX_CTX, _hx_tmp1);
HXLINE( 438)		 ::differ::shapes::Shape _hx_tmp2;
HXDLIN( 438)		if (flip) {
HXLINE( 438)			_hx_tmp2 = polygon1;
            		}
            		else {
HXLINE( 438)			_hx_tmp2 = polygon2;
            		}
HXDLIN( 438)		into->_hx_set_shape2(HX_CTX, _hx_tmp2);
HXLINE( 439)		into->separationX = (-(into->unitVectorX) * into->overlap);
HXLINE( 440)		into->separationY = (-(into->unitVectorY) * into->overlap);
HXLINE( 442)		if (flip) {
HXLINE( 443)			into->unitVectorX = -(into->unitVectorX);
HXLINE( 444)			into->unitVectorY = -(into->unitVectorY);
            		}
HXLINE( 447)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,checkPolygons,return )

Float SAT2D_obj::rayU(Float udelta,Float aX,Float aY,Float bX,Float bY,Float dX,Float dY){
            	HX_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_456_rayU)
HXDLIN( 456)		return (((dX * (aY - bY)) - (dY * (aX - bX))) / udelta);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(SAT2D_obj,rayU,return )

Float SAT2D_obj::findNormalAxisX(::Array< ::Dynamic> verts,int index){
            	HX_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_459_findNormalAxisX)
HXLINE( 460)		 ::differ::math::Vector v2;
HXDLIN( 460)		if ((index >= (verts->length - 1))) {
HXLINE( 460)			v2 = verts->__get(0).StaticCast<  ::differ::math::Vector >();
            		}
            		else {
HXLINE( 460)			v2 = verts->__get((index + 1)).StaticCast<  ::differ::math::Vector >();
            		}
HXLINE( 461)		return -((v2->y - verts->__get(index).StaticCast<  ::differ::math::Vector >()->y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(SAT2D_obj,findNormalAxisX,return )

Float SAT2D_obj::findNormalAxisY(::Array< ::Dynamic> verts,int index){
            	HX_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_464_findNormalAxisY)
HXLINE( 465)		 ::differ::math::Vector v2;
HXDLIN( 465)		if ((index >= (verts->length - 1))) {
HXLINE( 465)			v2 = verts->__get(0).StaticCast<  ::differ::math::Vector >();
            		}
            		else {
HXLINE( 465)			v2 = verts->__get((index + 1)).StaticCast<  ::differ::math::Vector >();
            		}
HXLINE( 466)		return (v2->x - verts->__get(index).StaticCast<  ::differ::math::Vector >()->x);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(SAT2D_obj,findNormalAxisY,return )


SAT2D_obj::SAT2D_obj()
{
}

bool SAT2D_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"tmp1") ) { outValue = ( tmp1 ); return true; }
		if (HX_FIELD_EQ(inName,"tmp2") ) { outValue = ( tmp2 ); return true; }
		if (HX_FIELD_EQ(inName,"rayU") ) { outValue = rayU_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"testRayVsRay") ) { outValue = testRayVsRay_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"checkPolygons") ) { outValue = checkPolygons_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"testRayVsCircle") ) { outValue = testRayVsCircle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"findNormalAxisX") ) { outValue = findNormalAxisX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"findNormalAxisY") ) { outValue = findNormalAxisY_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"testRayVsPolygon") ) { outValue = testRayVsPolygon_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"testCircleVsCircle") ) { outValue = testCircleVsCircle_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"testCircleVsPolygon") ) { outValue = testCircleVsPolygon_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"testPolygonVsPolygon") ) { outValue = testPolygonVsPolygon_dyn(); return true; }
	}
	return false;
}

bool SAT2D_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"tmp1") ) { tmp1=ioValue.Cast<  ::differ::data::ShapeCollision >(); return true; }
		if (HX_FIELD_EQ(inName,"tmp2") ) { tmp2=ioValue.Cast<  ::differ::data::ShapeCollision >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *SAT2D_obj_sMemberStorageInfo = 0;
static hx::StaticInfo SAT2D_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*  ::differ::data::ShapeCollision */ ,(void *) &SAT2D_obj::tmp1,HX_("tmp1",7a,d7,ff,4c)},
	{hx::fsObject /*  ::differ::data::ShapeCollision */ ,(void *) &SAT2D_obj::tmp2,HX_("tmp2",7b,d7,ff,4c)},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void SAT2D_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SAT2D_obj::tmp1,"tmp1");
	HX_MARK_MEMBER_NAME(SAT2D_obj::tmp2,"tmp2");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SAT2D_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SAT2D_obj::tmp1,"tmp1");
	HX_VISIT_MEMBER_NAME(SAT2D_obj::tmp2,"tmp2");
};

#endif

hx::Class SAT2D_obj::__mClass;

static ::String SAT2D_obj_sStaticFields[] = {
	HX_("testCircleVsPolygon",5b,ec,40,9e),
	HX_("testCircleVsCircle",4f,1f,15,71),
	HX_("tmp1",7a,d7,ff,4c),
	HX_("tmp2",7b,d7,ff,4c),
	HX_("testPolygonVsPolygon",55,7b,7e,51),
	HX_("testRayVsCircle",05,52,e5,b7),
	HX_("testRayVsPolygon",e5,18,9d,4d),
	HX_("testRayVsRay",d5,9a,06,df),
	HX_("checkPolygons",a1,85,ab,14),
	HX_("rayU",2b,57,a4,4b),
	HX_("findNormalAxisX",37,f1,b9,77),
	HX_("findNormalAxisY",38,f1,b9,77),
	::String(null())
};

void SAT2D_obj::__register()
{
	SAT2D_obj _hx_dummy;
	SAT2D_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("differ.sat.SAT2D",54,1b,e6,c6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &SAT2D_obj::__GetStatic;
	__mClass->mSetStaticField = &SAT2D_obj::__SetStatic;
	__mClass->mMarkFunc = SAT2D_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(SAT2D_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< SAT2D_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SAT2D_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SAT2D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SAT2D_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void SAT2D_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_188_boot)
HXDLIN( 188)		tmp1 =  ::differ::data::ShapeCollision_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_f57fec11f82d7dd3_189_boot)
HXDLIN( 189)		tmp2 =  ::differ::data::ShapeCollision_obj::__alloc( HX_CTX );
            	}
}

} // end namespace differ
} // end namespace sat
